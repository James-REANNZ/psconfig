#!/usr/bin/perl

=head1 NAME
 
remote - Add/delete/listremote URLs and associated parameters in agent configuration file
 
=head1 SYNOPSIS
 
remote add|delete|list [options] URL
 
 Options:
   -h | --help                  help message
   --transform JSON|@FILE       JSON transform object or a path to a file starting with @ that alters downloaded json
   --configure-archives         Indicates archives defined in remote URL should be used
   --bind-address ADDRESS       Local address to bind to when downloading JSON
   --ssl-validate-certificate   When using https, indicates hostname should be verified against CA
   --ssl-ca-file FILE           A typical certificate authority (CA) file found on BSD. Used to verify server SSL certificate when using https.
   --ssl-ca-path PATH           A typical certificate authority (CA) path found on Linux. Used to verify server SSL certificate when using https.

=head1 ARGUMENTS

=over 8

=item B<add|delete|list>
 
The action to perform

add: Adds remote definition to agent config file. If agent with same URL already exists then overwrites it.

delete: Deletes any entry with the matching options from the agent configuration file

list: Lists all the remote definitions currently in the agent configuration file. If no URL given lists all definition. If url and/or other parameters given, only matches those with same parameters.

=item B<URL>
 
A URL to the pSConfig JSON file. Not required for list. Can be of type http, https or file. If no prefix then assumed a local file.  

=back

=head1 OPTIONS
 
=over 8
 
=item B<-h | --help>
 
Prints a help message and exits

=item B<--transform JSON|@FILE>
 
JSON transform object or a path to a file starting with @ that alters downloaded json

=item B<--configure-archives>
 
Indicates archives defined in remote URL should be used

=item B<--bind-address>
 
Local address to bind to when downloading JSON

=item B<--ssl-validate-certificate>
 
When using https, indicates hostname should be verified against CA

=item B<--ssl-ca-file FILE>
 
A typical certificate authority (CA) file found on BSD. Used to verify server SSL certificate when using https.

=item B<--ssl-ca-path PATH>
 
A typical certificate authority (CA) path found on Linux. Used to verify server SSL certificate when using https.

=back
 
=head1 DESCRIPTION
 
B<This program> will add/delete/list remote URLs and associated parameters in agent configuration file.
 
=cut
use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/../../lib";

use Getopt::Long qw(GetOptions);
use JSON qw( from_json to_json );
use Pod::Usage;

use perfSONAR_PS::PSConfig::JQTransform;
use perfSONAR_PS::PSConfig::PScheduler::ConfigConnect;
use perfSONAR_PS::PSConfig::Remote;
use perfSONAR_PS::PSConfig::TransformConnect;

#TODO make config file configurable
#TODO add --quiet option
#TODO add --force option that does not check for existing
#TODO evaluate whether more sensible way to filter list
my $CONFIG_FILE="/etc/perfsonar/psconfig/pscheduler-agent.json";

#parse options
my $help;
my $transform_opt;
my $config_archives;
my $bind_address;
my $ssl_validate;
my $ssl_file;
my $ssl_path;
GetOptions(
    'help|h' => \$help,
    'transform=s' => \$transform_opt,
    'configure-archives' => \$config_archives,
    'bind-address=s' => \$bind_address,
    'ssl-validate-certificates' => \$ssl_validate,
    'ssl-ca-file=s' => \$ssl_file,
    'ssl-ca-path=s' => \$ssl_path,
) or pod2usage({ -verbose => 0, -exitval => 2 });

#parse arguments
if($help){
    pod2usage({ -exitval => 0, -verbose => 2, -noperldoc => 1});
}elsif(@ARGV == 0){
    my $exitval = 2;
    pod2usage({
        -message => "Must specify an ACTION(add, delete or list) and URL/file path to JSON file.",
        -exitval => $exitval,
        -verbose => 0   
    });
    exit $exitval;
}elsif(@ARGV > 2){
    my $exitval = 2;
    pod2usage({
        -message => "Too many parameters given. Only specify an ACTION(add, delete or list) and URL/file path to JSON file.",
        -exitval => $exitval,
        -verbose => 0
    });
    exit $exitval;
}
#get action
my $action = shift @ARGV;
chomp $action;
$action = lc($action);

#make sure we have URL
if($action eq 'add' || $action eq 'delete'){
    if(@ARGV != 1){
        my $exitval = 2;
        pod2usage({
            -message => "URL required for $action action",
            -exitval => $exitval,
            -verbose => 0
        });
        exit $exitval;
    }
}elsif($action ne 'list'){
    my $exitval = 2;
    pod2usage({
        -message => "Invalid action given: $action. Must be one of add, delete or list.",
        -exitval => $exitval,
        -verbose => 0
    });
    exit $exitval;
}

#get url
my $url;
if(@ARGV > 0){
     $url = shift @ARGV ;
    chomp $url;
}

#load config file
my ($agent_conf_client, $agent_conf) = _load_config($CONFIG_FILE);

#build remote
my $remote = new perfSONAR_PS::PSConfig::Remote();
$remote->url($url) if($url);
my $url_only_checksum = $remote->checksum();
$remote->configure_archives(1) if($config_archives);
$remote->bind_address($bind_address) if($bind_address);
$remote->ssl_validate_certificate(1) if($ssl_validate);
$remote->ssl_ca_file($ssl_file) if($ssl_file);
$remote->ssl_ca_path($ssl_file) if($ssl_path);
if($transform_opt){
    if($transform_opt =~ /^\@/){
        $transform_opt =~ s/^\@//;
        my $jqt = _load_transform($transform_opt);
        $remote->transform($jqt);
    }else{
        my $jqt = new JQTransform();
        $jqt->script($transform_opt);
        $remote->transform($jqt);
    }
}
my $remote_checksum = $remote->checksum();
my $is_url_only = ($url && $remote_checksum eq $url_only_checksum);

#perform action
my $success_msg = "";
if($action eq 'add'){
    $success_msg = "Added remote configuration $url";
    my $found = 0;
    for(my $i = 0; $i < @{$agent_conf->remotes()}; $i++){
        #if command just provided URL, match anything with that URL
        #if provided more, match entire checksum. 
        if($agent_conf->remote($i)->url() eq $remote->url()){
            $success_msg = "Replaced existing remote configuration for $url";
            $agent_conf->remote($i, $remote);
            $found = 1;
            last;
        }
    }
    $agent_conf->add_remote($remote) unless($found);
    _save_file($agent_conf_client, $agent_conf);
}elsif($action eq 'delete'){
    $success_msg = "No remote configuration for $url found";
    my $found = 0;
    for(my $i = 0; $i < @{$agent_conf->remotes()}; $i++){
        if(($is_url_only && $agent_conf->remote($i)->url() eq $remote->url()) ||
                (!$is_url_only && $agent_conf->remote($i)->checksum() eq $remote_checksum)){
            $success_msg = "Removed remote configuration for $url";
            $agent_conf->remove_list_item('remotes', $i);
            last;
        }
    }
    _save_file($agent_conf_client, $agent_conf);
}elsif($action eq 'list'){
    my $output = '[';
    my $printed = 0;
    foreach my $conf_remote(@{$agent_conf->remotes()}){
        if($is_url_only && $conf_remote->url() ne $url){
            next;
        }elsif(!$is_url_only && $url && $conf_remote->checksum() ne $remote_checksum){
            next;
        }
        if($printed){
            $output .= ',';
        }else{
            $printed = 1;
        }
        $output .= $conf_remote->json(); 
    }
    $output .= "]";
    #format nicely
    print to_json(from_json($output), {pretty=> 1});
}

#Finish
_success($success_msg);

#Subroutines
sub _success{
    my $msg = shift;
    print "$msg\n" if($msg);
    exit 0;
}

sub _error{
    my $msg = shift;
    print STDERR "$msg\n";
    exit 1;
}

sub _load_config {
    my ($config_file) = @_;
    
    ##
    #load config file
    my $agent_conf_client = new perfSONAR_PS::PSConfig::PScheduler::ConfigConnect(
        url => $config_file,
        save_filename => $config_file
    );
    if($agent_conf_client->error()){
        _error("Error opening $config_file: " . $agent_conf_client->error());
    } 
    my $agent_conf = $agent_conf_client->get_config();
    if($agent_conf_client->error()){
        _error("Error parsing $config_file: " . $agent_conf_client->error());
    }
    my @agent_conf_errors = $agent_conf->validate();
    if(@agent_conf_errors){
        my $err = "$config_file is not valid. The following errors were encountered: \n";
        foreach my $error(@agent_conf_errors){
            $err .= "    JSON Path: " . $error->path . "\n";
            $err .= "    Error: " . $error->message . "\n";
        }
        _error($err);
    }
    
    return ($agent_conf_client, $agent_conf);
}

sub _load_transform {
    my ($config_file) = @_;
    
    my $transform_client = new perfSONAR_PS::PSConfig::TransformConnect(url => $config_file);
    my $transform = $transform_client->get_config();
    if($transform_client->error()){
        _error("Error reading default transform file: " . $transform_client->error());
    } 
    #validate
    my @errors = $transform->validate();
    if(@errors){
        my $err = "$config_file is not a valid transform file. The following errors were encountered: \n";
        foreach my $error(@errors){
            my $path = $error->path;
            $path =~ s/^\/transform//; #makes prettier error message
            $err .= "    JSON Path: $path\n";
            $err .= "    Error: " . $error->message . "\n";
        }
        _error($err);
    }
    
    return $transform;
}

sub _save_file{
    my ($agent_conf_client, $agent_conf) = @_;
    $agent_conf_client->save_config($agent_conf, {'pretty' => 1});
    if($agent_conf_client->error()){
        _error("Error saving configuration: " . $agent_conf_client->error());
    }
}