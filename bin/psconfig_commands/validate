#!/usr/bin/perl

=head1 NAME
 
validate - Validate a pSConfig JSON file
 
=head1 SYNOPSIS
 
validate [options] FILE
 
 Options:
   -h | --help       help message
   -B | --bind ADDR  local address to bind to when sending http/https requests
   -q | --quiet      suppress output to stdout and stderr
   --skip-expand     skip expanding any include directives
   --timeout N       number of seconds to wait to retrieve JSON

=head1 ARGUMENTS

=over 8

=item B<FILE>
 
A path to a local file on the filesystem or an http(s) URL pointing at the JSON to validate.  

=back

=head1 OPTIONS
 
=over 8
 
=item B<-h | --help>
 
Prints a help message and exits

=item B<-B | --bind ADDR>
 
Local address to bind to when sending http/https requests

=item B<-q | --quiet>
 
Suppresses output to stdout and stderr. Useful when scripting and only concerned about exit code.

=item B<--skip-expand>
 
Skip expanding include directives and just validate schema prior to processing includes.

=item B<--timeout N>
 
The integer number of seconds to wait to retrieve JSON. Default is 0, which is no timeout. 
The timeout is applied to each individual request separately. For example, if you have two 
includes and a 30 second timeout, your program may spend up to 90 seconds retrieving 
files: 30s for the original file and 30s for both includes

=back
 
=head1 DESCRIPTION
 
B<This program> will read a JSON file from local filesystem or an http(s) URL and validate the JSON. An exit code of 0 indicates valid, 1 indicates it is invalid, and 2 indicates an error occurred.
 
=cut
use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/../../lib";
use Getopt::Long qw(GetOptions);
use Pod::Usage;

use perfSONAR_PS::Client::PSConfig::ApiConnect;
use perfSONAR_PS::Client::PSConfig::ApiFilters;

#parse options
my $bind;
my $quiet;
my $help;
my $skip_expand;
my $timeout = 0;
GetOptions(
    'help|h' => \$help,
    'bind|B=s' => \$bind,
    'quiet|q' => \$quiet,
    'skip-expand' => \$skip_expand,
    'timeout=i' => \$timeout
) or pod2usage({ -verbose => 0, -exitval => 2 });

#parse arguments
if($help){
    pod2usage({ -exitval => 0, -verbose => 2, -noperldoc => 1});
}elsif(@ARGV == 0){
    my $exitval = 2;
    pod2usage({
        -message => "Must specify a URL or file path to JSON file.",
        -exitval => $exitval,
        -verbose => 0   
    }) unless($quiet);
    exit $exitval;
}elsif(@ARGV > 1){
    my $exitval = 2;
    pod2usage({
        -message => "Only one file or URL can be specified on the command-line",
        -exitval => $exitval,
        -verbose => 0
    }) unless($quiet);
    exit $exitval;
}
#TODO: Validate URL and only add prefix if not a url but is existing file?
#unless otherwise specified assume a file
my $json_url = shift @ARGV;
chomp $json_url;

#read file  
my $psconfig_filters = new perfSONAR_PS::Client::PSConfig::ApiFilters(timeout => $timeout);
my $psconfig_client = new perfSONAR_PS::Client::PSConfig::ApiConnect(url => $json_url, filters => $psconfig_filters);
if($bind){
    $psconfig_client->bind_address($bind);
}
my $psconfig = $psconfig_client->get_config();
if($psconfig_client->error()){
    unless($quiet){
        print STDERR "Error retrieving JSON. Encountered the following error:\n\n";
        print STDERR "   " . $psconfig_client->error() . "\n";
    }
    exit 2;
} 

#validate schema
my @errors = $psconfig->validate();
if(@errors){
    unless($quiet){
        print STDERR "pSConfig JSON is not valid. Encountered the following validation errors:\n\n";
        foreach my $error(@errors){
            print STDERR "   Node: " . $error->path . "\n";
            print STDERR "   Error: " . $error->message . "\n\n";
        }
    }    
    exit 1;
}

######################
#handle includes
if(!$skip_expand && $psconfig->includes() && @{$psconfig->includes()} > 0){
    #expand includes
    $psconfig_client->expand_config($psconfig);
    if($psconfig_client->error()){
        unless($quiet){
            my @errors = split "\n", $psconfig_client->error();
            print STDERR "Error(s) encountered expanding includes:\n\n";
            foreach my $error(@errors){
                chomp $error;
                print STDERR "   $error\n" if($error);
            }
            
        }
        exit 1;
    }

    #validate again after expansion
    @errors = $psconfig->validate();
    if(@errors){
        unless($quiet){
            print STDERR "pSConfig JSON is not valid after expanding includes. Encountered the following validation errors:\n\n";
            foreach my $error(@errors){
                print STDERR "   Node: " . $error->path . "\n";
                print STDERR "   Error: " . $error->message . "\n\n";
            }
        }    
        exit 1;
    }
}

######################
#validate references
my $ref_errors = [];
#check addresses
foreach my $addr_name(@{$psconfig->address_names()}){
    my $address = $psconfig->address($addr_name);
    my $host_ref = $address->host_ref();
    my $context_refs = $address->context_refs();
    #check host ref
    if($host_ref && !$psconfig->host($host_ref)){
        push @{$ref_errors}, "Address $addr_name references a host object $host_ref that does not exist.";
    }
    #check context refs
    if($context_refs){
        foreach my $context_ref(@{$context_refs}){
            if(!$psconfig->context($context_ref)){
                push @{$ref_errors}, "Address $addr_name references a context object $context_ref that does not exist.";
            }
        }
    }
    #check remote addresses
    foreach my $remote_name(@{$address->remote_address_names()}){
        #check remote context refs
        my $remote = $address->remote_address($remote_name);
        if($remote->context_refs()){
            foreach my $context_ref(@{$remote->context_refs()}){
                if(!$psconfig->context($context_ref)){
                    push @{$ref_errors}, "Address $addr_name has a remote definition for $remote_name using a context object $context_ref that does not exist.";
                }
            }
        }
        #check remote labels
        foreach my $label_name(@{$remote->label_names()}){
            my $label = $address->label($label_name);
            if($label->context_refs()){
                foreach my $context_ref(@{$label->context_refs()}){
                    if(!$psconfig->context($context_ref)){
                        push @{$ref_errors}, "Address $addr_name has a label $label_name using a context object $context_ref that does not exist.";
                    }
                }
            }
        }
    }
    #check labels
    foreach my $label_name(@{$address->label_names()}){
        my $label = $address->label($label_name);
        #check label context refs
        if($label->context_refs()){
            foreach my $context_ref(@{$label->context_refs()}){
                if(!$psconfig->context($context_ref)){
                    push @{$ref_errors}, "Address $addr_name has a label $label_name using a context object $context_ref that does not exist.";
                }
            }
        }
    }
}
#check groups
foreach my $group_name(@{$psconfig->group_names()}){
    my $group = $psconfig->group($group_name);
    if($group->type() eq 'disjoint'){
        foreach my $a_addr_sel(@{$group->a_addresses()}){
            ref_check_addr_select($a_addr_sel, $group_name, $psconfig, $ref_errors);
        }
        foreach my $b_addr_sel(@{$group->b_addresses()}){
            ref_check_addr_select($b_addr_sel, $group_name, $psconfig, $ref_errors);
        }
    }elsif($group->can('addresses')){
        foreach my $addr_sel(@{$group->addresses()}){
            ref_check_addr_select($addr_sel, $group_name, $psconfig, $ref_errors);
        }
    }
}
#check hosts
foreach my $host_name(@{$psconfig->host_names()}){
    my $host = $psconfig->host($host_name);
    if($host->archive_refs()){
        foreach my $archive_ref(@{$host->archive_refs()}){
            if($archive_ref && !$psconfig->archive($archive_ref)){
                push @{$ref_errors}, "Host $host_name references an archive $archive_ref that does not exist.";
            }
        }
    }
}
#check tasks
foreach my $task_name(@{$psconfig->task_names()}){
    my $task = $psconfig->task($task_name);
    my $group_ref = $task->group_ref();
    my $test_ref = $task->test_ref();
    my $schedule_ref = $task->schedule_ref();
    
    #check group ref
    if($group_ref && !$psconfig->group($group_ref)){
        push @{$ref_errors}, "Task $task_name references a group $group_ref that does not exist.";
    }
    #check test ref
    if($test_ref && !$psconfig->test($test_ref)){
        push @{$ref_errors}, "Task $task_name references a test $test_ref that does not exist.";
    }
    #check schedule ref
    if($schedule_ref && !$psconfig->schedule($schedule_ref)){
        push @{$ref_errors}, "Task $task_name references a schedule $schedule_ref that does not exist.";
    }
    #check archive refs
    if($task->archive_refs()){
        foreach my $archive_ref(@{$task->archive_refs()}){
            if($archive_ref && !$psconfig->archive($archive_ref)){
                push @{$ref_errors}, "Task $task_name references an archive $archive_ref that does not exist.";
            }
        }
    }
}
#print any errors
if(@{$ref_errors}){
    foreach my $ref_error(@{$ref_errors}){
        _error($ref_error); 
    }
    exit 1;
}

_success();

#Subroutines
sub _success{
    print "pSConfig JSON is valid\n" unless($quiet);
    exit 0;
}

sub _error{
    my ($msg) = @_;
    print STDERR "$msg\n" unless($quiet);
}

sub ref_check_addr_select{
    my ($addr_sel, $group_name, $psconfig, $errors) = @_;
    
    if($addr_sel->can('name')){
        my $addr_name = $addr_sel->name();
        my $addr_obj = $psconfig->address($addr_name);
        unless($addr_obj){
            push @{$errors}, "Group $group_name references an address object $addr_name that does not exist.";
            return;
        }
        my $addr_label_name = $addr_sel->label();
        if($addr_label_name && !$addr_obj->label($addr_label_name)){
            push @{$errors}, "Group $group_name references a label $addr_label_name for address object $addr_name that does not exist.";
        }
    }elsif($addr_sel->can('class')){
        my $class_name = $addr_sel->class();
        unless($psconfig->address_class()){
            push @{$errors}, "Group $group_name references a class object $class_name that does not exist.";
            return;
        }
    }
}